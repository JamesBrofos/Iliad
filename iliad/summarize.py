from collections import OrderedDict
from typing import Optional, Sequence

import arviz
import numpy as np
import pandas as pd


def summarize(samples: np.ndarray, names: Optional[Sequence]=None, elapsed: Optional[float]=None):
    """Summarization code inspired by the NumPyro library.

    Copyright Contributors to the Pyro project. SPDX-License-Identifier:
    Apache-2.0.

    Args:
        samples: Array of samples generated by the Markov chain.
        names: Names of the variables sampled by the Markov chain. If not
            provided, assumes all of the variables are named `theta` with a
            numerical incremenent appended.
        elapsed: The time elapsed to produce the samples; in provided, we will
            compute the time-normalized effective sample size for each
            coefficient.

    """
    if names is None:
        names = ['theta-{}'.format(i+1) for i in range(samples.shape[-1])]

    samples = {n: s for n, s in zip(names, samples.T)}
    summary_dict = {}
    for n, s in samples.items():
        mean = np.mean(s)
        std = np.std(s)
        median = np.median(s)
        x = np.vstack(np.split(s, 2))
        ess = arviz.ess(x)
        rhat = arviz.rhat(x)
        summary_dict[n] = OrderedDict([
            ('mean', mean),
            ('std', std),
            ('median', median),
            ('rhat', rhat),
            ('ess', ess),
        ])
        if elapsed is not None:
            summary_dict[n]['ess-sec'] = ess / elapsed

    row_names = {k: k + '[' + ','.join(map(lambda x: str(x - 1), v.shape[2:])) + ']'
                 for k, v in samples.items()}
    max_len = max(max(map(lambda x: len(x), row_names.values())), 10)
    name_format = '{:>' + str(max_len) + '}'
    num_metrics = 6 if elapsed is not None else 5
    header_format = name_format + ' {:>9}' * num_metrics
    columns = [''] + list(list(summary_dict.values())[0].keys())

    print()
    print(header_format.format(*columns))
    row_format = name_format + ' {:>9.3f}' * num_metrics
    for name, stats_dict in summary_dict.items():
        shape = stats_dict["mean"].shape
        if len(shape) == 0:
            print(row_format.format(name, *stats_dict.values()))
        else:
            for idx in product(*map(range, shape)):
                idx_str = '[{}]'.format(','.join(map(str, idx)))
                print(row_format.format(name + idx_str, *[v[idx] for v in stats_dict.values()]))
    print()

    metrics = pd.DataFrame(summary_dict).T
    return metrics
